func customDiffComputeSnapshotSnapshotEncryptionKeys(diff *schema.ResourceDiff, meta interface{}) error {
	// oC -> Old Convenience Value
	// nC -> New Convenience Value
	// oN -> Old New Field Value
	// nN -> New New Field Value
	oC, nC := diff.GetChange("snapshot_encryption_key_raw")
	oN, nN := diff.GetChange("snapshot_encryption_key.0.raw_key")

	if nC != "" && nN != "" {
		return fmt.Errorf("can't use snapshot_encryption_key_raw and snapshot_encryption_key.0.raw_key at the same time." +
			"If you're removing snapshot_encryption_key.0.raw_key, set the value to \"\" instead. This is due to limitations in terraform plan.")
	}

	// Either field (convenience or new) has a value
	// and then has another different value, so we ForceNew.
	// We need to handle _EVERY_ ForceNew case in this diff
	if oC != "" && nC != "" && oC != nC {
		return diff.ForceNew("snapshot_encryption_key_raw")
	}

	if oN != "" && nN != "" && oN != nN {
		return diff.ForceNew("snapshot_encryption_key.0.raw_key")
	}

	// Our resource isn't using either field, then uses one;
	// ForceNew on whichever one is now using it.
	if (oC == "" && oN == "" && nC != "") || (oC == "" && oN == "" && nN != "") {
		if (oC == "" && nC != "") {
			return diff.ForceNew("snapshot_encryption_key_raw")
		} else {
			return diff.ForceNew("snapshot_encryption_key.0.raw_key")
		}
	}

	// convenience no longer used
	if oC != "" && nC == "" {
		if nN == "" {
			// convenience is being nulled, and the new field is empty as well
			// we've stopped using the field altogether
			return diff.ForceNew("snapshot_encryption_key_raw")
		} else if oC != nN {
			// convenience is being nulled, and the new field has a new value
			// so we ForceNew on either field
			return diff.ForceNew("snapshot_encryption_key_raw")
		} else {
			// If we reach it here, we're using the same value in the new field as we had in the convenience field
		}
	}

	// new no longer used
	// note that it will remain _set_ because Computed fields don't
	// lose diffs when unset, just to a 0 value.
	if oN != "" && nN == "" {
		if nC == "" {
			// new field is being nulled, and the convenience field is empty as well
			// we've stopped using the field altogether
			return diff.ForceNew("snapshot_encryption_key.0.raw_key")
		} else if oN != nC {
			// new is being nulled, and the convenience field has a new value
			// so we ForceNew on either field

			// This stops a really opaque diffs don't match during apply error. Without this, wee see
			// a diff from the old state -> new state with a ForceNew at plan time (as expected!)
			// But during apply time the entire nested object is nil in old state unexpectedly.
			// So we just force the diff to match more by nilling it here, which is unclear why it
			// works, and probably a worse UX with some real ugly diff, but also makes the tests pass.
			// Computed nested fields are hard.
			err := diff.SetNew("snapshot_encryption_key", nil)
			if err != nil {
				return err
			}

			return diff.ForceNew("snapshot_encryption_key.0.raw_key")
		} else {
			// If we reach it here, we're using the same value in the convenience field as we had in the new field
		}
	}

	return nil
}

func customDiffComputeSnapshotSourceDiskEncryptionKeys(diff *schema.ResourceDiff, meta interface{}) error {
	// oC -> Old Convenience Value
	// nC -> New Convenience Value
	// oN -> Old New Field Value
	// nN -> New New Field Value
	oC, nC := diff.GetChange("source_disk_encryption_key_raw")
	oN, nN := diff.GetChange("source_disk_encryption_key.0.raw_key")

	// Either field has a value and then has another value
	// We need to handle _EVERY_ ForceNew case in this diff
	if oC != "" && nC != "" && oC != nC {
			return diff.ForceNew("source_disk_encryption_key_raw")
	}

	if oN != "" && nN != "" && oN != nN {
			return diff.ForceNew("source_disk_encryption_key.0.raw_key")
	}

	// Our resource isn't using either field, then uses one;
	// ForceNew on whichever one is now using it.
	if (oC == "" && oN == "" && nC != "") || (oC == "" && oN == "" && nN != "") {
		if (oC == "" && nC != "") {
			return diff.ForceNew("source_disk_encryption_key_raw")
		} else {
			return diff.ForceNew("source_disk_encryption_key.0.raw_key")
		}
	}

	// convenience no longer used
	if oC != "" && nC == "" {
		if nN == "" {
			// convenience is being nulled, and the new field is empty as well
			// we've stopped using the field altogether
			return diff.ForceNew("source_disk_encryption_key_raw")
		} else if oC != nN {
			// convenience is being nulled, and the new field has a new value
			// so we ForceNew on either field
			return diff.ForceNew("source_disk_encryption_key_raw")
		} else {
			// If we reach it here, we're using the same value in the new field as we had in the convenience field
		}
	}

	// new no longer used
	if oN != "" && nN == "" {
		if nC == "" {
			// new field is being nulled, and the convenience field is empty as well
			// we've stopped using the field altogether
			return diff.ForceNew("source_disk_encryption_key.0.raw_key")
		} else if nC != oN {
			// new is being nulled, and the convenience field has a new value
			// so we ForceNew on either field
			return diff.ForceNew("source_disk_encryption_key.0.raw_key")
		} else {
			// If we reach it here, we're using the same value in the convenience field as we had in the new field
		}
	}

	return nil
}
